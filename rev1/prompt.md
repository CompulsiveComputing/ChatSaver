#Firefox Extension "ChatSaver" Project

ChatSaver will be a Firefox extension that automatically saves responses from predefined URLs to a predefined folder in real-time when they occur. The extension uses the webRequest and downloads APIs to capture and save the responses.

Attached are a list of files and their current contents, followed by a list of outlines and tasks that have not been marked as completed and other relevant information to the desired and current states of the project.

## ChatGPT Action Guidlines:
  A.When generating a response, ChatGPT will follow this outline
  B.Use the Markdown-quoted file-contents I have attached for context, any files existing inside the project are there verbatim (unless otherwise noted)
  C.Output any changes to files-contents necessary, specify begining and ending line numbers where changes begin and end (unless showing whole-file contents)
  D.Title and Output any files-contents needing updates
  E.ChatGPT will be given minified file-contents and output file-contents in the same style of minification
  F.When responding to this message, ChatGPT will first read all available context and then select one or more of the provided "Tasks", that are possible to be resolved in the current context. Changes may be on any number of filecontents but a char maximum of 2500 per response is mandatory.
  G.When writing functions, provide the bodies of only changed functions, I will simply move my copy of their contents to replace the empty {}
  H.Do not provide function bodies for ".summary." files

## Current File Contents

%% settings_page.html
```html
<!DOCTYPE html><html><head> <meta charset="UTF-8"> <title>ChatSaver Settings</title> <link rel="stylesheet" href="settings.css"></head><body> <h1>ChatSaver Settings</h1> <div id="recording-urls"> <h2>Recording URLs</h2> <ul id="url-list"></ul> <form id="add-url-form"> <label for="new-url">Add URL:</label> <input type="url" id="new-url" required> <input type="submit" value="Add"> </form> <\/div><div id="file-size-constraints"> <h2>File Size Constraints</h2> <form id="size-constraints-form"> <label for="min-size">Minimum size (bytes):</label> <input type="number" id="min-size" min="0" step="1" value="0"> <label for="max-size">Maximum size (bytes):</label> <input type="number" id="max-size" min="0" step="1" value="0"> <input type="submit" value="Update Constraints"> </form> <\/div><div id="file-extension"> <h2>File Extension</h2> <form id="extension-form"> <label for="file-extension">Extension:</label> <input type="text" id="file-extension" value=".txt"> <input type="submit" value="Update Extension"> </form> <\/div><div id="recordings-folder"> <h2>Recordings Folder</h2> <form id="folder-form"> <label for="folder">Folder:</label> <input type="text" id="folder" readonly> <button id="change-folder">Change</button> </form> <\/div><div id="recordings-parsers"> <h2>Recordings Parsers</h2> <ul id="parser-list"></ul> <button id="add-parser-button">Add New Parser</button> <\/div><div id="auto-delete-settings"> <h2>Auto-Delete</h2> <form id="auto-delete-form"> <label for="auto-delete-checkbox">Enable auto-delete:</label> <input type="checkbox" id="auto-delete-checkbox" name="auto-delete-checkbox" checked> <br><label for="min-age">Minimum age (days):</label> <input type="number" id="min-age" min="0" step="1" value="7"> <input type="submit" value="Update Settings"> </form> <\/div><div id="file-browser"> <h2>Recorded Responses Browser</h2> <button id="open-file-browser">Open File Browser</button> <p>Current recordings folder:<\/p><label id="folder-label"></label> <\/div><div id="auto-save-settings"> <h2>Auto-Save</h2> <form id="auto-save-form"> <label for="auto-save-checkbox">Enable auto-save:</label> <input type="checkbox" id="auto-save-checkbox" name="auto-save-checkbox" checked> <br><label for="save-interval">Save interval (seconds):</label> <input type="number" id="save-interval" min="1" step="1" value="10"> <input type="submit" value="Update Settings"> </form> <\/div><script src="settings.js"></script></body></html>
```
%%//settings_page.html

%% settings_page.js:
```js
import{getById, makeE, putListen, bMessage, createNotification, sanitizeFilename, getDateTimeCode}from './utils.js';async function updateFileExtension(extension){await browser.storage.local.set({recordingExtension: extension});}async function setDefaults(storage, defaults){for (const key in defaults){const result=await storage.get(key); if (typeof result[key]==='undefined'){const setting={}; setting[key]=defaults[key]; await storage.set(setting);}}const recordingsFolder=defaults.recordingFolder; const directory=await browser.downloads.download({url: 'data:application/octet-stream,', filename: recordingsFolder, conflictAction: 'uniquify', saveAs: false, incognito: false, method: 'POST',}); await browser.downloads.erase({id: directory});}function removeButtonClicked(url){bMessage({action: 'removeRecordingURL', url}); updateURLList();}async function updateAutoSaveSettings(enabled, interval){bMessage({action: 'updateAutoSaveSettings', enabled: enabled, interval: interval}); createNotification('Settings Saved', 'Auto-save settings have been updated.');}async function updateURLList(){bMessage({action: 'getSizeConstraints'}).then(({minSize, maxSize})=>{getById('min-size').value=minSize; getById('max-size').value=maxSize;}); bMessage({action: 'getRecordingURLs'}).then(async (urls)=>{const urlList=getById('url-list'); const{recordingFolder, recordingExtension}=await browser.storage.local.get(['recordingFolder', 'recordingExtension']); urlList.innerHTML=''; async function downloadUrl(url){const removeButton=makeE('button',{textContent: 'Remove', listeners: [{event: 'click', func: ()=>{removeButtonClicked(url);}}],}); const listItem=makeE('li',{textContent: url, children: [removeButton]}); urlList.appendChild(listItem); const filename=sanitizeFilename(url) + '-' + getDateTimeCode() + recordingExtension; const directory=await browser.downloads.download({url: url, filename: recordingFolder + '/' + sanitizeFilename(url) + '/' + filename, conflictAction: 'uniquify', saveAs: false, incognito: false, method: 'GET',});}for (const url of urls){const listItem=createUrlListItem(url); urlList.appendChild(listItem);}});}function createUrlListItem(url){const removeButton=makeE('button',{textContent: 'Remove', listeners: [{event: 'click', func: ()=>{removeButtonClicked(url);}}],}); const listItem=makeE('li',{textContent: url, children: [removeButton]}); return listItem;}async function saveResponse(url, responseText){const{recordingFolder, recordingExtension}=await browser.storage.local.get(['recordingFolder', 'recordingExtension']); const filename=sanitizeFilename(url) + '-' + getDateTimeCode() + recordingExtension; const blob=new Blob([responseText],{type: 'text/plain'}); const blobURL=URL.createObjectURL(blob); await browser.downloads.download({url: blobURL, filename: recordingFolder + '/' + sanitizeFilename(url) + '/' + filename, conflictAction: 'uniquify', saveAs: false, incognito: false,}); URL.revokeObjectURL(blobURL);}async function updateParserList(){const parsers=await browser.storage.local.get('parsers'); const parserList=getById('parser-list'); parserList.innerHTML=''; for (const parser of parsers.parsers){const editButton=makeE('button',{textContent: 'Edit', listeners: [{event: 'click', func: ()=> parserEditClicked(parser)}],}); const removeButton=makeE('button',{textContent: 'Remove', listeners: [{event: 'click', func: ()=> parserRemoveClicked(parser)}],}); const listItem=makeE('li',{textContent: parser.name, children: [editButton, removeButton]}); parserList.appendChild(listItem);}}async function parserEditClicked(parser){const newParser=prompt('Enter new parser code:', parser.parser); if (newParser){parser.parser=newParser; await browser.storage.local.set({parsers}); updateParserList(); saveSettings(); createNotification('Settings Saved', 'Parser has been edited.');}}async function parserRemoveClicked(parser){const index=parsers.parsers.indexOf(parser); parsers.parsers.splice(index, 1); await browser.storage.local.set({parsers}); updateParserList(); saveSettings(); createNotification('Settings Saved', 'Parser has been removed.');}async function updateFolderDisplay(){const{recordingFolder}=await browser.storage.local.get('recordingFolder'); getById('folder').value=recordingFolder;}async function changeFolderClicked(){const folder=await browser.runtime.sendMessage({action: 'selectFolder'}); if (folder){await browser.storage.local.set({recordingFolder: folder}); updateFolderDisplay(); createNotification('Settings Saved', 'Recordings folder has been updated.');}}function initialize(){const addParserButton=getById('add-parser-button'); addParserButton.addEventListener('click', async ()=>{const name=prompt('Enter parser name:'); const parser=prompt('Enter parser code:'); if (name && parser){const parsers=await browser.storage.local.get('parsers'); parsers.parsers.push({name, parser}); await browser.storage.local.set({parsers}); updateParserList(); saveSettings();}}); putListen(getById('auto-save-form'), 'submit', (event)=>{event.preventDefault(); const autoSaveCheckbox=getById('auto-save-checkbox'); const saveInterval=getById('save-interval').value; updateAutoSaveSettings(autoSaveCheckbox.checked, saveInterval);}); putListen(getById('add-pattern-form'), 'submit', async (event)=>{event.preventDefault(); const newPattern=getById('new-pattern').value; addRecordingURLPattern(newPattern); getById('new-pattern').value='';}); const changeFolderButton=getById('change-folder'); changeFolderButton.addEventListener('click', async ()=>{await changeFolderClicked();}); putListen(getById('extension-form'), 'submit', (event)=>{event.preventDefault(); const fileExtension=getById('file-extension').value; updateFileExtension(fileExtension);}); putListen(getById('auto-delete-toggle'), 'change', async (event)=>{await toggleAutoDelete(event.target.checked);}); saveSettings();}initialize();browser.runtime.onMessage.addListener(async (message)=>{if (message.action==='getRecordingFolder'){const{recordingFolder}=await browser.storage.local.get('recordingFolder'); return recordingFolder;}});async function handleSettingsMessage(message, storage){switch (message.action){case 'updateSizeConstraints': const sizeConstraints={minSize: parseInt(message.minSize), maxSize: parseInt(message.maxSize),}; await storage.set({sizeConstraints}); return sizeConstraints; case 'updateAutoSaveSettings': const autoSaveSettings={enabled: message.enabled, interval: parseInt(message.interval),}; await storage.set({autoSaveSettings}); if (autoSaveSettings.enabled){const saveInterval=autoSaveSettings.interval * 60 * 1000; setInterval(()=>{bMessage({action: 'saveRecordings'});}, saveInterval);}return autoSaveSettings; default: return null;}}async function getSettings(){const{recordingFolder, recordingExtension, sizeConstraints}=await browser.storage.local.get([ 'recordingFolder', 'recordingExtension', 'sizeConstraints']); return{recordingFolder, recordingExtension, sizeConstraints};}async function saveSettings(){const{recordingFolder, recordingExtension, sizeConstraints}=await getSettings(); getById('min-size').value=sizeConstraints.minSize; getById('max-size').value=sizeConstraints.maxSize; getById('file-extension').value=recordingExtension; getById('folder').value=recordingFolder; updateURLList(); updateParserList();}async function sendSizeConstraints(){const minSize=parseInt(getById('min-size').value); const maxSize=parseInt(getById('max-size').value); bMessage({action: 'updateSizeConstraints', minSize, maxSize});}async function addRecordingURLPattern(pattern){const{urlPatterns}=await browser.storage.local.get('urlPatterns'); urlPatterns.push(pattern); await browser.storage.local.set({urlPatterns}); updateURLPatternList();}async function removeRecordingURLPattern(pattern){const{urlPatterns}=await browser.storage.local.get('urlPatterns'); const index=urlPatterns.indexOf(pattern); if (index > -1){urlPatterns.splice(index, 1); await browser.storage.local.set({urlPatterns});}updateURLPatternList();}async function updateURLPatternList(){const{urlPatterns}=await browser.storage.local.get('urlPatterns'); const patternList=getById('pattern-list'); patternList.innerHTML=''; for (const pattern of urlPatterns){const removeButton=makeE('button',{textContent: 'Remove', listeners: [{event: 'click', func: ()=> removeRecordingURLPattern(pattern)}],}); const listItem=makeE('li',{textContent: pattern, children: [removeButton],}); patternList.appendChild(listItem);}}browser.webRequest.onCompleted.addListener( async (details)=>{if (details.method==='GET'){const urls=await browser.storage.local.get('recordingURLs'); for (const url of urls.recordingURLs){if (details.url.startsWith(url)){const responseText=await (await fetch(details.url)).text(); saveResponse(url, responseText); break;}}}},{urls: ['<all_urls>']});async function toggleAutoDelete(enabled){await browser.storage.local.set({autoDelete: enabled}); createNotification('Settings Saved', 'Auto-delete setting has been updated.');}
```
%%//settings_page.js

%% settings_page.css: 
```css
body{font-family: Arial, sans-serif; margin: 1em;}h1{font-size: 1.5em; margin-bottom: 1em;}ul{list-style: none; margin: 0; padding: 0;}li{display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5em;}label{display: block; margin-bottom: 0.5em;}input{font-size: 1em; padding: 0.5em; border-radius: 4px; border: 1px solid #ccc;}button{font-size: 1em; padding: 0.5em; border-radius: 4px; border: 1px solid #ccc; cursor: pointer; background-color: #f8f8f8; transition: background-color 0.2s;}button:hover{background-color: #e8e8e8;}input[type="submit"]{width: 100%; margin-top: 1em; background-color: #f8f8f8; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; padding: 0.5em; cursor: pointer; transition: background-color 0.2s;}input[type="submit"]:hover{background-color: #e8e8e8;}
```
%%//settings_page.css

%% background.js:
```js
import{createNotification, sanitizeFilename}from './utils.js';init();const Parser_Manager=function (){const Parsers=[]; return{};}();const File_Folder_Manager=function (){const Files=[]; const Folders=[]; /*TODO*/ return{saveResponseToFile: saveReceivedFile, findOrMakeRecordingsFolder, deleteSelectedResponses, setSelectedResponses, getSelectedResponses, getOrCreateFile, deleteOldResponses}; async function saveReceivedFile(url, responseHeaders, requestBody, responseData){const datetimeCode=new Date().toISOString().replace(/[:.]/g, "-"); const extension=responseData.headers["content-type"].split("/")[1]; const recordingExtension=await Settings_Manager.getRecordingExtension(); const sanitizedUrl=sanitizeFilename(url); const filename=`${sanitizedUrl}-${datetimeCode}.${extension}${recordingExtension}`; const dirPath=await getOrCreateDirectory(url); const filepath=`${dirPath}/${filename}`; const sanitizedResponse=sanitizeFilename(responseData.body); const blob=new Blob([sanitizedResponse],{type: responseData.headers["content-type"]}); const urlObj=URL.createObjectURL(blob); try{const downloadId=await browser.downloads.download({url: urlObj, filename: filepath, saveAs: false,}); createNotification("ChatSaver", `Response saved: ${filename}`);}catch (error){console.error("Error downloading file:", error);}finally{URL.revokeObjectURL(urlObj);}}async function findOrMakeRecordingsFolder(){const recordingFolder=await Settings_Manager.getRecordingFolder(); const recordingsFolderExists=await browser.storage.local.get(recordingFolder); let recordingsFolderId; if (!recordingsFolderExists[recordingFolder]){try{const createdFolder=await browser.bookmarks.create({title: recordingFolder, url: null, parentId: "unfiled_bookmarks",}); recordingsFolderId=createdFolder.id; await browser.storage.local.set({[recordingFolder]: recordingsFolderId});}catch (error){console.error("Error creating recordings folder:", error); throw error;}}else{recordingsFolderId=recordingsFolderExists[recordingFolder];}return `place:${recordingsFolderId}`;}async function deleteSelectedResponses(){const selectedResponses=await getSelectedResponses(); if (selectedResponses.length===0){return;}const urls=selectedResponses.map(r=> r.url); const recordingFolder=await Settings_Manager.getRecordingFolder(); for (const url of urls){const directoryPath=`${recordingFolder}/${sanitizeFilename(url)}`; const contents=await browser.storage.local.get(directoryPath); for (const key in contents){if (key !==directoryPath){await browser.storage.local.remove(key);}}await browser.storage.local.remove(directoryPath);}}function setSelectedResponses(urlList){browser.storage.local.set({selectedResponses: urlList});}function getSelectedResponses(){const{selectedResponses=[]}=browser.storage.local.get(); return selectedResponses;}async function getOrCreateDirectory(url){const recordingFolder=await Settings_Manager.getRecordingFolder(); const sanitizedUrl=sanitizeFilename(url); const urlPath=`${recordingFolder}/${sanitizedUrl}`; const directoryExists=await browser.storage.local.get(urlPath); if (!directoryExists[urlPath]){await browser.storage.local.set({[urlPath]: true});}return urlPath;}async function deleteOldResponses(){const autoDeleteSettings=await Settings_Manager.getAutoDeleteSettings(); if (autoDeleteSettings.enabled){const recordingsFolder=await Settings_Manager.getRecordingFolder(); const minAge=autoDeleteSettings.minAge * 24 * 60 * 60 * 1000; const recordingsFolderPath=browser.runtime.getURL(recordingsFolder); const entries=await browser.storage.local.get(); const currentTimestamp=new Date().getTime(); let emptyDirectories=new Set(); for (const entry in entries){if (entry.startsWith(recordingsFolderPath)){const entryTimestamp=parseInt(entry.split("/").pop().split("-")[0]); if (isNaN(entryTimestamp)){continue;}if (currentTimestamp - entryTimestamp >=minAge){await browser.storage.local.remove(entry); const directoryPath=entry.substring(0, entry.lastIndexOf('/')); if (!emptyDirectories.has(directoryPath)){const directoryContents=Object.keys(entries).filter(e=> e.startsWith(directoryPath)); if (directoryContents.length===0){emptyDirectories.add(directoryPath);}}}}}for (const directory of emptyDirectories){await browser.storage.local.remove(directory);}}}}();const Settings_Manager=function (){const defaults={recordingFolder: "ChatSaver", recordingURLs: ["https://chat.example.com/example/chats"], sizeConstraints:{minSize: 0, maxSize: 0}, recordingExtension: ".txt", autoDeleteSettings:{enabled: false, minAge: 7}}; const settings=browser.storage.local.get(defaults); return{isRecordingURL, getFileSizeConstraints, setFileSizeConstraints, getRecordingFolderPath, setRecordingFolderPath, getRecordingURLs, setRecordingURLs, getRecordingExtension, setRecordingExtension, getAutoDeleteSettings, setAutoDeleteSettings, SaveSettings, ReloadSettings}; function getRecordingExtension(){return settings.recordingExtension;}function setRecordingExtension(extension){settings.recordingExtension=extension;}function isRecordingURL(url){let recordingURLs=settings.recordingURLs; for (let recordingURL of recordingURLs){if (url.startsWith(recordingURL)){return true;}}return false;}function getFileSizeConstraints(){return settings.sizeConstraints;}function setFileSizeConstraints(min, max){settings.sizeConstraints.minSize=min; settings.sizeConstraints.maxSize=max;}function getRecordingFolderPath(){return settings.recordingFolder;}function setRecordingFolderPath(path){settings.recordingFolder=path;}async function SaveSettings(){await browser.storage.local.set(settings);}async function ReloadSettings(){settings=await browser.storage.local.get(defaults);}function getAutoDeleteSettings(){return settings.autoDeleteSettings;}function getRecordingURLs(){return settings.recordingURLs;}function setRecordingURLs(urlList){settings.recordingURLs=urlList;}async function setAutoDeleteSettings(enabled, minAge){settings.autoDeleteSettings.enabled=enabled; settings.autoDeleteSettings.minAge=minAge;}}();async function init(){await Settings_Manager.ReloadSettings(); const recordingURLs=await Settings_Manager.getRecordingURLs(); browser.webRequest.onCompleted.addListener( async ({url, statusCode, responseHeaders, requestBody, responseData})=>{if (statusCode===200 && await Settings_Manager.isRecordingURL(url)){await File_Folder_Manager.saveReceivedFile(url, responseHeaders, requestBody, responseData);}},{urls: recordingURLs}, ["responseHeaders"] ); browser.runtime.onMessage.addListener(async message=>{/*TODO*/ switch (message.action){case "addRecordingURL": case "removeRecordingURL": case "getRecordingURLs": case "selectFolder": case "updateSizeConstraints": case "updateRecordingExtension": case "updateRecordingFolder": case "toggleAutoDelete": case "updateAutoDeleteSettings": case "getAutoDeleteSettings": default: break;}});}export{Settings_Manager, File_Folder_Manager, Parser_Manager, message, init};
```
%%//background.js

%% file_browser_page.html
```html
<!DOCTYPE html><html><head> <meta charset="UTF-8"> <title>ChatSaver File Browser</title> <link rel="stylesheet" type="text/css" href="file_browser.css"></head><body> <div id="directory-tree"><\/div><div id="file-list"> <h1>Files in selected directory:</h1> <ul id="files"></ul> <button id="delete-selected">Delete Selected</button> <button id="download-all">Download All</button> <button id="download-selected">Download Selected</button> <\/div><script src="file_browser.js"></script></body></html>
```
%%//file_browser_page.html

%% file_browser_page.css: 
```css
#directory-tree{margin: 1em;}#directory-tree ul{list-style-type: none; margin: 0; padding: 0;}#directory-tree li{margin-left: 1em; position: relative;}#directory-tree li:before{content: ""; position: absolute; top: 0; bottom: 0; left: -0.5em; border-left: 1px solid #ccc;}#directory-tree li:last-child:before{height: auto; top: 0.5em; bottom: 0;}#directory-tree a{display: inline-block; padding: 0.25em 0;}#file-list{margin: 1em;}#file-list ul{list-style-type: none; margin: 0; padding: 0;}#file-list li{margin-bottom: 0.5em;}#file-list li a{display: inline-block; padding: 0.25em 0;}
```
%%//file_browser_page.css

%% file_browser_page.js
```js
import{sanitizeFilename, getById , makeE, bMessage}from './utils.js';(async function (){const storage=browser.storage.local; const{recordingFolder}=await storage.get("recordingFolder"); const fileList=getById("file-list"); const directoryTree=getById("directory-tree"); async function createFileList(folderPath){const files=await browser.downloads.search({directory: folderPath}); const ul=makeE('ul'); files.forEach((file)=>{const li=makeE('li'); const a=makeE('a'); a.href=URL.createObjectURL(file.url); a.textContent=file.filename; a.download=file.filename; const checkbox=makeE('input'); checkbox.type='checkbox'; checkbox.dataset.fileId=file.id; li.insertBefore(checkbox, a); li.appendChild(a); ul.appendChild(li);}); fileList.innerHTML=''; fileList.appendChild(ul);}async function createDirectoryTree(){const files=await browser.downloads.search({directory: recordingFolder}); const directories={}; files.forEach((file)=>{const dir=file.directory.slice(recordingFolder.length + 1).split('/')[0]; if (!directories[dir]){directories[dir]=[];}directories[dir].push(file);}); const ul=makeE('ul'); for (const dir in directories){const li=makeE('li'); const a=makeE('a'); a.textContent=dir; a.href='#'; a.dataset.path=`${recordingFolder}/${dir}`; a.onclick=(event)=>{event.preventDefault(); const target=event.target; document.querySelectorAll('#directory-tree a').forEach((a)=> a.removeAttribute('selected')); target.setAttribute('selected', ''); createFileList(target.dataset.path);}; if (dir===''){a.setAttribute('selected', ''); createFileList(recordingFolder);}li.appendChild(a); ul.appendChild(li);}directoryTree.innerHTML=''; directoryTree.appendChild(ul);}await createDirectoryTree(); getById('delete-selected').addEventListener('click', async ()=>{const selectedFiles=Array.from(document.querySelectorAll('#file-list input[type="checkbox"]:checked')).map(checkbox=>{return{id: parseInt(checkbox.dataset.fileId)};}); if (selectedFiles.length > 0){if (confirm('Are you sure you want to delete the selected files?')){await bMessage({action: 'deleteSelectedResponses', files: selectedFiles}); const selectedDir=document.querySelector('#directory-tree a[selected]'); const selectedPath=selectedDir ? selectedDir.dataset.path : recordingFolder; await createFileList(selectedPath); await createDirectoryTree();}}else{alert('Please select files to delete.');}}); getById('download-all').addEventListener('click', async ()=>{const selectedDir=document.querySelector('#directory-tree a[selected]'); const selectedPath=selectedDir ? selectedDir.dataset.path : recordingFolder; const files=await browser.downloads.search({directory: selectedPath}); files.forEach((file)=>{browser.downloads.download({url: file.url, filename: file.filename});});}); getById('download-selected').addEventListener('click', async ()=>{const selectedFiles=Array.from(document.querySelectorAll('#file-list input[type="checkbox"]:checked')).map(checkbox=>{return{url: URL.createObjectURL(checkbox.nextSibling.href), filename: checkbox.nextSibling.textContent};}); if (selectedFiles.length > 0){selectedFiles.forEach((file)=>{browser.downloads.download({url: file.url, filename: file.filename});});}else{alert('Please select files to download.');}});})(); 
```
%%//file_browser_page.js

%% utils.js
```js
function getById(id){return document.getElementById(id);}function createNotification(title, message){browser.notifications.create({type: 'basic', iconUrl: browser.extension.getURL('icon.svg'), title: title, message: message,});}function makeE(type){return document.createElement(type);}function putListen(element, listener){return element.addEventListener(listener);}function sanitizeFilename(filename){return filename.replace(/[^a-z0-9_\-.]/gi, '_');}function bMessage(message){return browser.runtime.sendMessage(message);}export{sanitizeFilename, getById, createNotification, autoDelete, bMessage, makeE, putListen};
```
%%//utils.js

%% Manifest.json: 
```json
{"manifest_version": 2, "name": "ChatSaver", "version": "1.0", "description": "Automatically save responses from predefined URLs to a predefined folder in real-time when they occur", "permissions": [ "downloads", "webRequest", "webRequestBlocking", "<all_urls>", "downloads.open", "notifications", "storage"], "background":{"scripts": [ "background.js"], "persistent": true}, "browser_action":{"default_icon": "icon.svg", "default_popup": "popup.html", "default_title": "ChatSaver"}, "options_ui":{"page": "settings.html", "browser_style": true}, "web_accessible_resources": [ "file_browser.html", "file_browser.css", "file_browser.js"]}
```
%%//Manifest.json

%% icon.svg: 
```html
<svg width="48" height="48" viewBox="0 0 48 48" fill="blank" xmlns="http://www.w3.org/2000/svg"> <rect x="0" y="0" width="48" height="48" rx="0" fill="#FFFFFF" stroke="rgba(0,0,0,0.8)" stroke-width="0.02em"/> <rect x="4" y="4" width="40" height="40" rx="4" fill="#193b1b" stroke="rgba(0,0,0,0.8)" stroke-width="0.02em"/> <rect x="6" y="6" width="36" height="36" rx="4" fill="rgba(255,255,255,0.288)" stroke="rgba(0,0,0,0.8)" stroke-width="0.02em"/> <text x="50%" y="33%" text-anchor="middle" dy="0.3em" font-family="Arial" font-size="18" fill="#c5c5c5" stroke="rgba(0,0,0,0.8)" stroke-width="0.02em">Chat</text> <text x="50%" y="66%" text-anchor="middle" dy="0.3em" font-family="Arial" font-size="18" fill="#c5c5c5" stroke="rgba(0,0,0,0.8)" stroke-width="0.02em">Saver</text></svg>
```
%%//icon.svg

%% popup_window.html: 
```html
<!DOCTYPE html><html><head> <link rel="stylesheet" href="popup.css"></head><body> <h1>ChatSaver</h1> <div id="menu"> <button id="menu-button">Menu</button> <div id="menu-content" class="hidden"> <button id="open-folder">Open Recording Folder</button> <button id="open-settings">Open Settings</button> <p>Recorded Responses: <span id="this_pages_and_refreshes_collated_responses" data-displaylimit="5"></span><\/p><\/div><\/div><form id="add-url-form"> <label for="new-url">Add URL:</label> <input type="url" id="new-url" required> <input type="submit" value="Add"> </form> <div id="notification"><\/div><script src="popup.js"></script></body></html>
```
%%//popup_window.html

%% popup_window.js: 
```js
import{getById, makeE, putListen, bMessage, createNotification}from './utils.js';getById('add-url-form').addEventListener('submit', (event)=>{event.preventDefault(); const newURL=getById.value; bMessage({action: 'addRecordingURL', url: newURL}); updateURLList(); getById('new-url').value='';});getById('passive-button').addEventListener('click', ()=>{const menuContent=getById('menu-content'); menuContent.classList.toggle('hidden');});getById('open-settings').addEventListener('click', ()=>{const urlWindow=window.open('url_list.html', 'Recording URLs', 'width=300,height=400');});getById('menu-button').addEventListener('click', ()=>{const menuContent=getById('menu-content'); menuContent.classList.toggle('hidden');});document.onload=updateURLList();bMessage({action: 'getSavedResponsesCount'}).then((count)=>{const savedResponses=getById('this_pages_and_refreshes_collated_responses'); savedResponses.textContent=count;});browser.runtime.onMessage.addListener((message)=>{if (message.action==='showNotification'){const notification=getById('notification'); notification.textContent=message.text; notification.classList.add('show'); setTimeout(()=>{notification.classList.remove('show');}, 3000);}});
```
%%//popup_window.js

%% popup_window.css: 
```css
body{font-family: Arial, sans-serif; margin: 1rem;}#menu{position: relative; display: inline-block;}#menu-content{position: absolute; top: 2.5em; right: 0; display: none; background-color: #f9f9f9; box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2); padding: 1em; border-radius: 4px; z-index: 1;}#menu-content button{display: block; width: 100%; margin-bottom: 0.5em;}#menu-button{font-size: 1rem; padding: 0.5em; border: 1px solid #ccc; border-radius: 4px; background-color: #f8f8f8; transition: background-color 0.2s;}#menu-button:hover{background-color: #e8e8e8;}.hidden{display: none;}
```
%%//popup_window.css

## Project Goals:
  1.save responses from predefined URLs to a predefined folder in realtime when they occur
  2.Saved responses will be saved to sub-directories named similairly to their URLs (but sanitized and uniquified)
  3.Saved responses will be named similairly to their URL + DateTimeCode + original extension + ".noexec"
  4.File Browser will have a 
    4.1(Directory-tree showing all files) and a
    4.2(large UI element that is proceedurally populated by pre-defined (extension/datatype)-parsing functions located in parsers (defaults to a simple hex editor interface for extensions with no other parser)) to directly investigate saved responses
  5.notify the user when a new response has been saved.
  6.automatically delete old responses based on a specified time limit (IF user specifies they want it!)

## Computing Environment
 Firefox
 Windows

## Tasks
 -Iterate and implement code in/on/for background.js
 -Give code-snippets that user can use to update their files
 -Find inconsistencies or duplications in current code to update, merge duplicates if functionality is missing from one
 -Find missing functions detailed in the outline

## ChatGPT's Turn