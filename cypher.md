# Compressing text by substitution

## Task

Use the following substitution cypher "listicle.json" to create a markdown-quoted field containing cyphered copy the "stuff to cypher" below it
Use[ and ] as control characters strictly for enclosing sequences that are not cyphered
Use { and } as control chatacters strictly for enclosing the run length of the token(s) prior to the comma (eg "{i1 ,16}" to encode "i1 " as repeated 16 times)
Not allow to nest encoded "control character enclosed & encoded content" inside other "enclosed content"
First specify the array, then specify the element number (starting at 0) (eg n0 is "0" and g1 is "function")

Such as example half-assed compressed text: "g0 p16s5t0  t3{ ,16}l5 [Flaming jehosifats i1o1p1t1 I won the lotorry!]"

## listicle.json :
```json
{
    "n": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "l": ["a", "o", "t", "i", "n", "s", "r", "l", "c", "d", "u", "p", "m", "h", "b", "g", "f", "v", "k", "y", "w", "x", "j", "q", "z"],
    "c": ["A", "O", "T", "I", "N", "S", "R", "L", "C", "D", "U", "P", "M", "H", "B", "G", "F", "V", "K", "Y", "W", "X", "J", "Q", "Z"],
    "s": ["<", ">", "/", "=", "-", ".", ",", ":", ";", "{", "}", "(", ")", "[", "]", "&", "$", "@", "*", "+", "#", "%", "!"],
    "g": ["import", "function", "async", "await", "for", "const", "let", "in", "of", "true", "false", "null", "undefined", "if", "else", "switch", "case", "break", "return", "new", "throw", "typeof", "default", "catch", "finally", "try", "export", "default", "class", "extends", "super", "constructor", "this", "from", "get", "set", "prototype", "Object", "Array", "Promise", "Error", "setTimeout", "setInterval", "clearTimeout", "clearInterval", "fetch", "Blob", "URL", "Date", "RegExp", "Math", "parseInt", "parseFloat", "isNaN", "Infinity", "NaN", "Number", "String", "Boolean", "Symbol", "Map", "Set", "WeakMap", "WeakSet", "JSON", "console", "window", "document", "XMLHttpRequest", "FormData", "navigator", "history", "localStorage", "sessionStorage", "chrome", "browser", "runtime", "webRequest", "tabs", "pageAction", "browserAction", "contentScripts", "create", "download", "downloads", "button", "Notification", "notification", "get", "put", "update", "uniquify", "add", "remove"],
    "e": ["Recording", "Settings", "URLs", "Recording URLs", "File Size Constraints", "Minimum size (bytes)", "Maximum size (bytes)", "Update Constraints", "File Extension", "Extension", "Update Extension", "Recordings Folder", "Folder", "Change", "Recordings Parsers", "Auto-Delete", "Enable auto-delete", "Minimum age (days)", "Update Settings", "Recorded Responses Browser", "Open File Browser", "Auto-Save", "Enable auto-save", "Save interval (seconds)", "Update Settings", "button", "form", "input", "label", "ul", "li", "h1", "h2", "head", "meta", "body", "html", "title", "link", "style", "script", "select"],
    "t": ["data", "application", "octet-stream", "POST", "GET", "text", "plain", "text/plain", "utf-8", "UTF-8", "stylesheet", "text/css", "number", "url", "checkbox", "submit", "button", "file", "readonly", "required", "step", "min", "incognito", "uniquify", "conflictAction", "saveAs", "fromCache", "filename", "filenameRegex", "expirationDate", "hostPermissions", "cookies", "webRequest", "activeTab", "storage", "contextMenus", "notifications", "alarms", "identity", "idle", "runtime", "tabs", "webNavigation", "windows", "history", "menus", "pageAction", "browserAction", "bookmarks", "topSites", "devtools", "downloads", "management", "extension", "experimental", "unlimitedStorage", "privacy", "proxy", "nativeMessaging", "debugger", "accessibilityFeatures", "contentSettings", "debuggee", "enterprise.platformKeys", "enterprise.deviceAttributes", "enterprise.networkingAttributes", "power", "printerProvider", "usbDevices", "fontSettings", "hid", "serial", "tts", "vpnProvider"],
    "p": ["JavaScript", "Python", "Java", "C++", "C#", "Ruby", "Swift", "Go", "Kotlin", "TypeScript", "HTML", "CSS", "React", "Vue", "Angular", "Node.js", "Express.js", "Django", "Flask", "Rails", "Spring", "Hibernate", "JUnit", "Selenium", "Jest", "Mocha", "Chai", "Cypress", "Webpack", "Babel", "ESLint", "Prettier", "Git", "GitHub", "Bitbucket", "JIRA", "Slack", "Trello", "Asana", "VSCode", "IntelliJ", "Eclipse", "PyCharm", "WebStorm", "Atom", "Sublime", "Notepad++", "Emacs", "Vim", "Docker", "Kubernetes", "AWS", "GCP", "Azure", "Firebase", "Heroku", "DigitalOcean", "MongoDB", "MySQL", "PostgreSQL", "SQLite", "Redis", "Elasticsearch", "GraphQL", "REST", "OAuth", "JWT", "WebSocket"]
}
```


## stuff to cypher:
```js
import{getById,makeE,putListen,bMessage,createNotification,sanitizeFilename,getDateTimeCode}from"./utils.js";async function updateFileExtension(e){await browser.storage.local.set({recordingExtension:e})}async function setDefaults(e,t){for(const n in t){const a=await e.get(n);if(typeof a[n]==="undefined"){const a={};a[n]=t[n];await e.set(a)}}const n=t.recordingFolder;const a=await browser.downloads.download({url:"data:application/octet-stream,",filename:n,conflictAction:"uniquify",saveAs:false,incognito:false,method:"POST"});await browser.downloads.erase({id:a})}function removeButtonClicked(e){bMessage({action:"removeRecordingURL",url:e});updateURLList()}async function updateAutoSaveSettings(e,t){bMessage({action:"updateAutoSaveSettings",enabled:e,interval:t});createNotification("Settings Saved","Auto-save settings have been updated.")}async function updateURLList(){bMessage({action:"getSizeConstraints"}).then((({minSize:e,maxSize:t})=>{getById("min-size").value=e;getById("max-size").value=t}));bMessage({action:"getRecordingURLs"}).then((async e=>{const t=getById("url-list");const{recordingFolder:n,recordingExtension:a}=await browser.storage.local.get(["recordingFolder","recordingExtension"]);t.innerHTML="";async function s(e){const s=makeE("button",{textContent:"Remove",listeners:[{event:"click",func:()=>{removeButtonClicked(e)}}]});const r=makeE("li",{textContent:e,children:[s]});t.appendChild(r);const o=sanitizeFilename(e)+"-"+getDateTimeCode()+a;const i=await browser.downloads.download({url:e,filename:n+"/"+sanitizeFilename(e)+"/"+o,conflictAction:"uniquify",saveAs:false,incognito:false,method:"GET"})}for(const t of e){await s(t)}}))}async function saveResponse(e,t){const{recordingFolder:n,recordingExtension:a}=await browser.storage.local.get(["recordingFolder","recordingExtension"]);const s=sanitizeFilename(e)+"-"+getDateTimeCode()+a;const r=new Blob([t],{type:"text/plain"});const o=URL.createObjectURL(r);await browser.downloads.download({url:o,filename:n+"/"+sanitizeFilename(e)+"/"+s,conflictAction:"uniquify",saveAs:false,incognito:false});URL.revokeObjectURL(o)}async function updateParserList(){const e=await browser.storage.local.get("parsers");const t=getById("parser-list");t.innerHTML="";for(const n of e.parsers){const e=makeE("button",{textContent:"Edit",listeners:[{event:"click",func:()=>parserEditClicked(n)}]});const a=makeE("button",{textContent:"Remove",listeners:[{event:"click",func:()=>parserRemoveClicked(n)}]});const s=makeE("li",{textContent:n.name,children:[e,a]});t.appendChild(s)}}async function parserEditClicked(e){const t=prompt("Enter new parser code:",e.parser);if(t){e.parser=t;await browser.storage.local.set({parsers:parsers});updateParserList();saveSettings();createNotification("Settings Saved","Parser has been edited.")}}async function parserRemoveClicked(e){const t=parsers.parsers.indexOf(e);parsers.parsers.splice(t,1);await browser.storage.local.set({parsers:parsers});updateParserList();saveSettings();createNotification("Settings Saved","Parser has been removed.")}async function updateFolderDisplay(){const{recordingFolder:e}=await browser.storage.local.get("recordingFolder");getById("folder").value=e}async function changeFolderClicked(){const e=await browser.runtime.sendMessage({action:"selectFolder"});if(e){await browser.storage.local.set({recordingFolder:e});updateFolderDisplay();createNotification("Settings Saved","Recordings folder has been updated.")}}function initialize(){const e=getById("add-parser-button");e.addEventListener("click",(async()=>{const e=prompt("Enter parser name:");const t=prompt("Enter parser code:");if(e&&t){const n=await browser.storage.local.get("parsers");n.parsers.push({name:e,parser:t});await browser.storage.local.set({parsers:n});updateParserList();saveSettings()}}));putListen(getById("auto-save-form"),"submit",(e=>{e.preventDefault();const t=getById("auto-save-checkbox");const n=getById("save-interval").value;updateAutoSaveSettings(t.checked,n)}));putListen(getById("add-pattern-form"),"submit",(async e=>{e.preventDefault();const t=getById("new-pattern").value;addRecordingURLPattern(t);getById("new-pattern").value=""}));const t=getById("change-folder");t.addEventListener("click",(async()=>{await changeFolderClicked()}));putListen(getById("extension-form"),"submit",(e=>{e.preventDefault();const t=getById("file-extension").value;updateFileExtension(t)}));saveSettings()}initialize();browser.runtime.onMessage.addListener((async e=>{if(e.action==="getRecordingFolder"){const{recordingFolder:e}=await browser.storage.local.get("recordingFolder");return e}}));async function handleSettingsMessage(e,t){switch(e.action){case"updateSizeConstraints":const n={minSize:parseInt(e.minSize),maxSize:parseInt(e.maxSize)};await t.set({sizeConstraints:n});return n;case"updateAutoSaveSettings":const a={enabled:e.enabled,interval:parseInt(e.interval)};await t.set({autoSaveSettings:a});if(a.enabled){const e=a.interval*60*1e3;setInterval((()=>{bMessage({action:"saveRecordings"})}),e)}return a;default:return null}}async function getSettings(){const{recordingFolder:e,recordingExtension:t,sizeConstraints:n}=await browser.storage.local.get(["recordingFolder","recordingExtension","sizeConstraints"]);return{recordingFolder:e,recordingExtension:t,sizeConstraints:n}}async function saveSettings(){const{recordingFolder:e,recordingExtension:t,sizeConstraints:n}=await getSettings();getById("min-size").value=n.minSize;getById("max-size").value=n.maxSize;getById("file-extension").value=t;getById("folder").value=e;updateURLList();updateParserList()}async function sendSizeConstraints(){const e=parseInt(getById("min-size").value);const t=parseInt(getById("max-size").value);bMessage({action:"updateSizeConstraints",minSize:e,maxSize:t})}async function addRecordingURLPattern(e){const{urlPatterns:t}=await browser.storage.local.get("urlPatterns");t.push(e);await browser.storage.local.set({urlPatterns:t});updateURLPatternList()}async function removeRecordingURLPattern(e){const{urlPatterns:t}=await browser.storage.local.get("urlPatterns");const n=t.indexOf(e);if(n>-1){t.splice(n,1);await browser.storage.local.set({urlPatterns:t})}updateURLPatternList()}async function updateURLPatternList(){const{urlPatterns:e}=await browser.storage.local.get("urlPatterns");const t=getById("pattern-list");t.innerHTML="";for(const n of e){const e=makeE("button",{textContent:"Remove",listeners:[{event:"click",func:()=>removeRecordingURLPattern(n)}]});const a=makeE("li",{textContent:n,children:[e]});t.appendChild(a)}}browser.webRequest.onCompleted.addListener((async e=>{if(e.method==="GET"){const t=await browser.storage.local.get("recordingURLs");for(const n of t.recordingURLs){if(e.url.startsWith(n)){const t=await(await fetch(e.url)).text();saveResponse(n,t);break}}}}),{urls:["<all_urls>"]});
```
